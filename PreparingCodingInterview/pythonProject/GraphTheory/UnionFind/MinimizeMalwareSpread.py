from typing import List, DefaultDict
from collections import defaultdict


class DSU:
    def __init__(self, n: int):
        self.n: int = n
        self.par: List[int] = [-1] * n

    def find(self, u: int) -> int:
        if self.par[u] < 0:
            return u
        self.par[u] = self.find(self.par[u])

        return self.par[u]

    def join(self, u: int, v: int) -> bool:
        par_u = self.find(u)
        par_v = self.find(v)

        if par_u == par_v:
            return False

        self.par[par_u] += self.par[par_v]
        self.par[par_v] = par_u

        return True

    def get_score(self, u: int) -> int:
        return self.par[self.find(u)]


class MinMalwareSpreadSolution:
    def __init__(self, graph: List[List[int]], initial: List[int]):
        self.g: List[List[int]] = graph
        self.initial: List[int] = sorted(initial)

    def solve(self) -> int:
        if len(self.initial) == 1:
            return self.initial[0]
        n = len(self.g)

        dsu: DSU = DSU(n)

        for u in range(n):
            for v in range(u+1, n):
                if self.g[u][v] == 1:
                    dsu.join(u, v)

        together: DefaultDict[int, bool] = defaultdict(bool)

        m = len(self.initial)

        for i in range(m):
            for j in range(i+1, m):
                u, v = self.initial[i], self.initial[j]
                if dsu.find(u) == dsu.find(v):
                    together[u] = together[v] = True

        record = 0
        arg_min = -1

        for u in self.initial:

            if together[u]:
                continue
            if arg_min == -1:
                arg_min = u
                record = dsu.get_score(u)
                continue
            cd_record = dsu.get_score(u)
            if cd_record < record:
                record, arg_min = cd_record, u

        return arg_min if arg_min >= 0 else self.initial[0]

if __name__ == '__main__':
    graph = [[1,1,1],[1,1,1],[1,1,1]]
    initial = [1,2]

    print(MinMalwareSpreadSolution(graph, initial).solve())





